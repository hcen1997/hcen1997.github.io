---
layout: post
---
## 前置公理
* 代码是有进化过程的, 但是用户看到的是最后的好看的产品(这个能卖钱)
* 
### 原始算法
1. 隔位计算 (i&0x55555555) +  ((i>>>1)&0x55555555 )
2. 把这两位的数加成4位
3. 把这4位的数加成8位
4. 4个8位加成2个16位
5  两个16位加和输出结果  |

### 原始代码
```java
i= (i&0x55555555) +  ((i>>>1)&0x55555555 ); 
i= (i&0x33333333) +  ((i>>>2)&0x33333333 );
i= (i&0x0F0F0F0F) +  ((i>>>4)&0x0F0F0F0F );
i= (i&0x00FF00FF) +  ((i>>>8)&0x00FF00FF );
i= (i&0x0000FFFF) +  ((i>>>16)&0x0000FFFF );
```
### 优化
第一行可以被数学优化  
第二行不能优化(全1会涉及进位)  
第3,4,5行因为没有进位可以被优化
3,4,5行优化原则是 (加完后)(使用掩码)(丢掉)(影响下一步计算的部分)

第一行:  
```text
// n == b0 + b1*2 +b2*2^2 + ... + b31*2^31
// n>>>1 == b1 + b2*2^1 + ... + b31*2^30
// xx = n>>>1 & 0x55555555 (0101)  ==
//     b1 + b3*2^2 + b5*2^4 + ... + b31*2^30
// xxy = n&0x55555555 ==
//     b0 + b2*2^2 + ... + b30*2^30
//  n = xxy + xx + xx
显然 n - xx = xxy + xx  ==> 
           n-((n>>>1) & 0x55555555) = 
            (i&0x55555555) + ((i>>>1)&0x55555555)
```

第3,4,5行:
* 3行: 
  * i+(i>>>4) 后 ax & 0x0f0f0f0f 即为所求
* 4行: 
  * 因为已经使用掩码去掉了影响计算的部分, 
  所以可以不用继续处理高位的残留位,
    i + (i >>> 8) 足以算出正确答案
* 5行: 
  * 因为已经使用掩码去掉了影响计算的部分,
  所以可以不用继续处理高位的残留位,
  i + (i >>> 16) 足以算出正确答案

最后返回时 使用掩码抹去超过32的高位  
0x3f,十进制64,刚好抹去高位残留

### 最终代码
```java
 public static int bitCount(int i) {
        // HD, Figure 5-2
        i = i - ((i >>> 1) & 0x55555555);
        i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
        i = (i + (i >>> 4)) & 0x0f0f0f0f;
        i = i + (i >>> 8);
        i = i + (i >>> 16);
        return i & 0x3f;
    }
```
## 图
![img](assets/img/hd_5_1.jpg)
### 总结
写这个代码的人是个黑客